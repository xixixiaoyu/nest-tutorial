<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NestJS 提供者(Provider)详解</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 280px;
            background-color: #f8f9fa;
            padding: 20px;
            border-right: 1px solid #e9ecef;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }
        
        .sidebar h2 {
            margin-bottom: 20px;
            color: #343a40;
            font-size: 1.5rem;
        }
        
        .sidebar ul {
            list-style: none;
        }
        
        .sidebar li {
            margin-bottom: 10px;
        }
        
        .sidebar a {
            color: #495057;
            text-decoration: none;
            display: block;
            padding: 5px 0;
            border-left: 3px solid transparent;
            padding-left: 10px;
            transition: all 0.2s;
        }
        
        .sidebar a:hover {
            color: #0d6efd;
            border-left-color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.05);
        }
        
        .sidebar .sub-menu {
            margin-left: 15px;
            margin-top: 5px;
            display: none;
        }
        
        .sidebar .active > .sub-menu {
            display: block;
        }
        
        .sidebar .active > a {
            color: #0d6efd;
            border-left-color: #0d6efd;
            font-weight: 500;
        }
        
        .content {
            flex: 1;
            padding: 30px;
            margin-left: 280px;
            max-width: calc(100% - 280px);
        }
        
        h1, h2, h3, h4 {
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            color: #212529;
        }
        
        h1 {
            font-size: 2.5rem;
            border-bottom: 2px solid #f1f3f5;
            padding-bottom: 0.5em;
            margin-top: 0;
        }
        
        h2 {
            font-size: 2rem;
        }
        
        h3 {
            font-size: 1.5rem;
        }
        
        h4 {
            font-size: 1.25rem;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        pre {
            margin: 1.5em 0;
            border-radius: 6px;
            overflow: auto;
        }
        
        code {
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.9em;
            background-color: #f1f3f5;
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        ul, ol {
            margin-bottom: 1rem;
            padding-left: 2rem;
        }
        
        .section {
            scroll-margin-top: 30px;
        }
        
        .note {
            background-color: #e7f5ff;
            border-left: 4px solid #4dabf7;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .warning {
            background-color: #fff9db;
            border-left: 4px solid #ffd43b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5em 0;
        }
        
        table, th, td {
            border: 1px solid #e9ecef;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
        }
        
        th {
            background-color: #f8f9fa;
        }
        
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <h2>目录</h2>
        <ul>
            <li><a href="#introduction">提供者简介</a></li>
            <li><a href="#what-is-provider">什么是提供者？</a></li>
            <li><a href="#create-service">创建服务</a></li>
            <li><a href="#use-service">在控制器中使用服务</a></li>
            <li><a href="#register-provider">注册提供者</a></li>
            <li><a href="#async-provider">异步提供者</a></li>
            <li>
                <a href="#advanced">提供者的进阶玩法</a>
                <ul class="sub-menu">
                    <li><a href="#scope">作用域</a></li>
                    <li><a href="#optional">可选依赖</a></li>
                    <li><a href="#property-injection">属性注入</a></li>
                    <li><a href="#manual-instance">手动获取实例</a></li>
                    <li><a href="#custom-provider">自定义提供者</a></li>
                </ul>
            </li>
        </ul>
    </aside>
    
    <main class="content">
        <h1>NestJS 提供者(Provider)详解</h1>
        
        <section id="introduction" class="section">
            <p>在 Nest 的世界里，提供者（Provider）就像是应用程序的"专业工匠"。
            如果把应用比作一座房子，那么提供者就是电工、木匠、水管工这些各司其职的专业人士。
            每个提供者都有自己的专长，通过依赖注入的方式为应用提供服务。</p>
        </section>
        
        <section id="what-is-provider" class="section">
            <h2>什么是提供者？</h2>
            <p>提供者本质上是一个可以被注入到其他类中的类。它们承担着不同的职责：</p>
            <ul>
                <li>服务（Service）：处理业务逻辑和数据操作</li>
                <li>仓库（Repository）：专门负责与数据库打交道</li>
                <li>工厂（Factory）：负责创建复杂对象</li>
                <li>辅助类（Helper）：提供各种通用功能</li>
            </ul>
            <p>提供者最大的优势就是可以通过依赖注入（Dependency Injection）的方式被"送达"到需要它们的地方，这让代码变得更加模块化和可测试。</p>
        </section>
        
        <section id="create-service" class="section">
            <h2>创建你的一个服务 (Service)</h2>
            <p>让我们通过一个管理猫咪信息的例子来了解如何创建服务。假设我们需要一个 CatsService 来处理所有关于猫咪的操作：</p>
            <pre><code class="language-typescript">import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable() // 这个装饰器是关键
export class CatsService {
  private readonly cats: Cat[] = []; // 用数组模拟数据库

  create(cat: Cat) {
    this.cats.push(cat);
    console.log('一只新猫咪加入了！现在有', this.cats.length, '只猫咪。');
  }

  findAll(): Cat[] {
    console.log('正在查找所有猫咪...');
    return this.cats;
  }
}</code></pre>
            <p><code>@Injectable()</code> 装饰器相当于告诉 Nest：CatsService 这个类是个提供者，你可以管理它，也可以把它'注入'给别人用。</p>
        </section>
        
        <section id="use-service" class="section">
            <h2>在控制器中使用服务</h2>
            <p>现在我们有了 CatsService，接下来看看如何在控制器中使用它：</p>
            <pre><code class="language-typescript">import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateCatDto } from './dto/create-cat.dto';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
  // 通过构造函数注入 CatsService
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
    return '成功添加了一只猫咪！';
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}</code></pre>
            <p>这里的关键是构造函数中的 <code>constructor(private readonly catsService: CatsService)</code>。
            你只需要声明需要什么类型的依赖，NestJS 就会自动创建实例并注入进来。这就是依赖注入的魔法。</p>
        </section>
        
        <section id="register-provider" class="section">
            <h2>注册提供者</h2>
            <p>光定义服务还不够，你还需要告诉 Nest 这个服务的存在。这就需要在模块中注册它：</p>
            <pre><code class="language-typescript">// cats.module.ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService], // 在这里注册服务
  exports: [CatsService],   // 如果其他模块需要使用，记得导出
})
export class CatsModule {}</code></pre>
            <p>然后在主模块中导入这个特性模块：</p>
            <pre><code class="language-typescript">// app.module.ts
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule], // 导入特性模块
})
export class AppModule {}</code></pre>
            <p>当 Nest 初始化 CatsController 时，发现它需要 CatsService，依赖注入系统就会自动找到已注册的提供者，实例化它并注入到控制器中。</p>
        </section>
        
        <section id="async-provider" class="section">
            <h2>异步提供者：处理复杂的初始化</h2>
            <p>想象一下这样的场景：你的应用需要在启动时连接数据库，只有连接成功后，其他服务才能正常工作。如果用传统方式，你可能需要写一堆回调或者 Promise 链，代码会变得复杂且难以维护。</p>
            <p>异步提供者的解决方案非常直观，它使用 async/await 配合 useFactory：</p>
            <pre><code class="language-typescript">import { DataSource } from 'typeorm';

// 在模块的 providers 中配置
{
  provide: 'DATABASE_CONNECTION',
  useFactory: async (): Promise<DataSource> => {
    const dataSource = new DataSource({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      database: 'myapp',
      // 其他配置...
    });
    
    await dataSource.initialize();
    console.log('数据库连接建立成功！');
    return dataSource;
  },
}</code></pre>
            <p>Nest 会智能地检测到你的 useFactory 函数是异步的，然后耐心等待 Promise 完成。只有当数据库连接真正建立后，那些依赖这个连接的服务才会开始实例化。</p>
            <p>在服务中注入使用：</p>
            <pre><code class="language-typescript">import { Injectable, Inject } from '@nestjs/common';
import { DataSource } from 'typeorm';

@Injectable()
export class UserService {
  constructor(
    @Inject('DATABASE_CONNECTION') 
    private readonly dataSource: DataSource
  ) {}

  async findAllUsers() {
    const userRepository = this.dataSource.getRepository(User);
    return await userRepository.find();
  }

  async createUser(userData: CreateUserDto) {
    const userRepository = this.dataSource.getRepository(User);
    const user = userRepository.create(userData);
    return await userRepository.save(user);
  }
}</code></pre>
            <p>如果你的工厂函数还需要其他依赖，可以通过 inject 参数注入：</p>
            <pre><code class="language-typescript">import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: 'DATABASE_CONNECTION',
      useFactory: async (configService: ConfigService) => {
        // 异步初始化逻辑
      },
      inject: [ConfigService],
    },
    UserService,
  ],
  exports: ['DATABASE_CONNECTION'],
})
export class DatabaseModule {}</code></pre>
        </section>
        
        <section id="advanced" class="section">
            <h2>提供者的一些进阶玩法</h2>
            
            <section id="scope" class="section">
                <h3>作用域</h3>
                <p>NestJS 中的提供者默认采用单例模式（整个应用共享一个实例），但可以根据业务需求调整作用域。</p>
                
                <h4>1. DEFAULT（默认单例）</h4>
                <pre><code class="language-typescript">import { Injectable } from '@nestjs/common';

@Injectable() // 等同于 @Injectable({ scope: Scope.DEFAULT })
export class UserService {
  private users: User[] = [];
  
  // 整个应用生命周期内只有一个实例
  // 所有模块共享同一个实例
  constructor() {
    console.log('UserService 实例创建');
  }
}</code></pre>
                
                <h4>2. REQUEST（请求作用域）</h4>
                <pre><code class="language-typescript">import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class RequestScopedService {
  private requestData: any = {};
  
  // 每个 HTTP 请求创建新实例
  // 适合存储请求特有的信息（如用户信息、请求ID等）
  constructor() {
    console.log('RequestScopedService 实例创建');
  }
}</code></pre>
                
                <h4>3. TRANSIENT（瞬态作用域）</h4>
                <pre><code class="language-typescript">import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {
  private instanceId = Math.random();
  
  // 每次注入都创建新实例
  // 完全独立的状态管理
  constructor() {
    console.log(`TransientService 实例创建，ID: ${this.instanceId}`);
  }
}</code></pre>
                
                <h4>使用场景对比</h4>
                <table>
                    <thead>
                        <tr>
                            <th>作用域</th>
                            <th>性能</th>
                            <th>内存占用</th>
                            <th>适用场景</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>DEFAULT</td>
                            <td>最优</td>
                            <td>最低</td>
                            <td>无状态服务、工具类、数据库连接</td>
                        </tr>
                        <tr>
                            <td>REQUEST</td>
                            <td>中等</td>
                            <td>中等</td>
                            <td>用户认证、请求日志、请求上下文</td>
                        </tr>
                        <tr>
                            <td>TRANSIENT</td>
                            <td>较差</td>
                            <td>较高</td>
                            <td>需要完全隔离状态的特殊场景</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <section id="optional" class="section">
                <h3>可选依赖</h3>
                <p>有时某些依赖不是必需的，可以使用 <code>@Optional()</code> 装饰器：</p>
                <pre><code class="language-typescript">import { Injectable, Optional } from '@nestjs/common';

@Injectable()
export class AppService {
  constructor(
    @Optional() private readonly analyticsService?: AnalyticsService
  ) {
    // analyticsService 可能为 undefined
    if (this.analyticsService) {
      this.analyticsService.track('AppService initialized');
    }
  }
  
  doSomething() {
    // 使用前需要检查是否存在
    this.analyticsService?.track('Action performed');
  }
}</code></pre>
                <p>这在开发插件系统或可选功能时特别有用。</p>
            </section>
            
            <section id="property-injection" class="section">
                <h3>属性注入</h3>
                <p>除了构造函数注入，Nest 也支持属性注入：</p>
                <pre><code class="language-typescript">import { Injectable, Inject } from '@nestjs/common';

@Injectable()
export class CatsService {
  @Inject(ConfigService)
  private readonly configService: ConfigService;
  
  getSettings() {
    return this.configService.get('cats');
  }
}</code></pre>
                <p>不过，通常还是推荐用构造函数注入，因为依赖关系更清晰，也更便于测试。</p>
            </section>
            
            <section id="manual-instance" class="section">
                <h3>手动获取实例</h3>
                <p>有时需要在运行时动态获取提供者实例，可以使用 ModuleRef：</p>
                <pre><code class="language-typescript">import { Injectable, ModuleRef } from '@nestjs/core';
import { UserService } from '../user/user.service';
import { LoggerService } from '../logger/logger.service';

@Injectable()
export class DynamicService {
  constructor(private moduleRef: ModuleRef) {}

  async getUserData(userId: string) {
    // 动态获取用户服务
    const userService = this.moduleRef.get(UserService);
    
    // 获取请求范围的日志服务（每次请求都是新实例）
    const logger = await this.moduleRef.resolve(LoggerService);
    
    logger.log(`Getting user data for ${userId}`);
    return userService.findById(userId);
  }

  async getServiceByName(serviceName: string) {
    try {
      // 根据字符串 token 动态获取服务
      const service = this.moduleRef.get(serviceName, { strict: false });
      return service;
    } catch (error) {
      console.log(`Service ${serviceName} not found`);
      return null;
    }
  }
}</code></pre>
            </section>
            
            <section id="custom-provider" class="section">
                <h3>自定义提供者</h3>
                <p>到目前为止，我们看到的提供者都是基于类的。但 Nest 的依赖注入系统非常灵活，它不仅支持提供类作为 Provider，还可以提供：</p>
                <ul>
                    <li>普通值 (Value Providers)： 使用 useValue 提供常量、配置对象等。</li>
                    <li>类 (Class Providers)： 使用 useClass 提供一个类的实例（我们之前看到的默认方式）。</li>
                    <li>工厂函数 (Factory Providers)： 使用 useFactory 根据动态逻辑（可以是同步或异步）创建和提供实例（如之前的数据库连接示例）。</li>
                    <li>别名 (Alias Providers)： 使用 useExisting 为已存在的提供者创建一个别名或不同的 token。</li>
                </ul>
                <p>这种灵活性使得你可以用非常精细的方式来管理和提供应用程序中的各种依赖。我们后面会单独介绍下各种自定义提供者的具体使用方式和场景。</p>
            </section>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 处理目录点击事件
            const menuItems = document.querySelectorAll('.sidebar a');
            menuItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    const parent = item.parentElement;
                    if (parent.querySelector('.sub-menu')) {
                        parent.classList.toggle('active');
                    }
                });
            });

            // 根据滚动位置高亮当前目录项
            const sections = document.querySelectorAll('.section');
            window.addEventListener('scroll', () => {
                let current = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    const sectionHeight = section.clientHeight;
                    if (pageYOffset >= sectionTop - 100) {
                        current = section.getAttribute('id');
                    }
                });

                menuItems.forEach(item => {
                    item.parentElement.classList.remove('active');
                    if (item.getAttribute('href') === `#${current}`) {
                        item.parentElement.classList.add('active');
                        
                        // 如果是子菜单项，也激活父菜单
                        const parentLi = item.closest('.sub-menu')?.parentElement;
                        if (parentLi) {
                            parentLi.classList.add('active');
                        }
                    }
                });
            });
        });
    </script>
</body>
</html>
